#!/usr/bin/env python3
"""
Simple local CLI password manager.
Storage: an encrypted JSON object written to file (default ./secrets/passwords.dat)
Dependecies: cryptography

Usage:
  python tools/password_manager.py init
  python tools/password_manager.py add --name github --user alice --password 'p@ssw0rd'
  python tools/password_manager.py get --name github
  python tools/password_manager.py list
  python tools/password_manager.py remove --name github
  python tools/password_manager.py change-master
  python tools/password_manager.py export --out exported.dat
  python tools/password_manager.py import --in exported.dat
"""

import argparse, json, os, base64, getpass, pathlib, sys
from typing import Dict
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes
from cryptography.fernet import Fernet, InvalidToken
from cryptography.hazmat.backends import default_backend

DEFAULT_DB = pathlib.Path("secrets") / "passwords.dat"
SALT_SIZE = 16
KDF_ITERS = 390000

def derive_key(password: bytes, salt: bytes) -> bytes:
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt,
        iterations=KDF_ITERS,
        backend=default_backend()
    )
    return base64.urlsafe_b64encode(kdf.derive(password))

def read_db(path: pathlib.Path, master: bytes):
    if not path.exists():
        raise FileNotFoundError("DB not found; run 'init' first.")
    raw = path.read_bytes()
    # file layout: salt (16 bytes) + ciphertext
    salt = raw[:SALT_SIZE]
    ciphertext = raw[SALT_SIZE:]
    key = derive_key(master, salt)
    f = Fernet(key)
    try:
        dec = f.decrypt(ciphertext)
        return json.loads(dec.decode()), salt
    except InvalidToken:
        raise ValueError("Invalid master password (decryption failed).")

def write_db(path: pathlib.Path, master: bytes, data: Dict, salt: bytes=None):
    path.parent.mkdir(parents=True, exist_ok=True)
    if salt is None:
        salt = os.urandom(SALT_SIZE)
    key = derive_key(master, salt)
    f = Fernet(key)
    payload = json.dumps(data, indent=2).encode()
    ciphertext = f.encrypt(payload)
    path.write_bytes(salt + ciphertext)

def prompt_master(confirm=False):
    p = getpass.getpass("Master password: ")
    if confirm:
        p2 = getpass.getpass("Confirm master password: ")
        if p != p2:
            print("Passwords do not match.", file=sys.stderr)
            sys.exit(2)
    return p.encode()

def cmd_init(args):
    db = pathlib.Path(args.db)
    if db.exists() and not args.force:
        print(f"DB {db} already exists. Use --force to overwrite.", file=sys.stderr)
        sys.exit(1)
    master = prompt_master(confirm=True)
    write_db(db, master, {}, salt=None)
    print(f"Initialized new DB at {db}")

def cmd_add(args):
    db = pathlib.Path(args.db)
    master = prompt_master()
    try:
        data, salt = read_db(db, master)
    except Exception as e:
        print("Error reading DB:", e, file=sys.stderr); sys.exit(2)
    name = args.name
    entry = {"user": args.user or "", "password": args.password or ""}
    if args.password is None:
        # interactively ask for password
        entry["password"] = getpass.getpass("Entry password: ")
    data[name] = entry
    write_db(db, master, data, salt)
    print(f"Saved entry '{name}'")

def cmd_get(args):
    db = pathlib.Path(args.db)
    master = prompt_master()
    try:
        data, _ = read_db(db, master)
    except Exception as e:
        print("Error reading DB:", e, file=sys.stderr); sys.exit(2)
    name = args.name
    if name not in data:
        print("No such entry.", file=sys.stderr); sys.exit(1)
    entry = data[name]
    print(json.dumps({ "name": name, "user": entry.get("user",""), "password": entry.get("password","") }, indent=2))

def cmd_list(args):
    db = pathlib.Path(args.db)
    master = prompt_master()
    try:
        data, _ = read_db(db, master)
    except Exception as e:
        print("Error reading DB:", e, file=sys.stderr); sys.exit(2)
    for k,v in data.items():
        print(f"- {k} (user: {v.get('user','')})")

def cmd_remove(args):
    db = pathlib.Path(args.db)
    master = prompt_master()
    try:
        data, salt = read_db(db, master)
    except Exception as e:
        print("Error reading DB:", e, file=sys.stderr); sys.exit(2)
    if args.name in data:
        del data[args.name]
        write_db(db, master, data, salt)
        print(f"Removed '{args.name}'")
    else:
        print("No such entry.", file=sys.stderr); sys.exit(1)

def cmd_change_master(args):
    db = pathlib.Path(args.db)
    old = getpass.getpass("Current master password: ").encode()
    try:
        data, _ = read_db(db, old)
    except Exception as e:
        print("Error reading DB (wrong master?):", e, file=sys.stderr); sys.exit(2)
    new = prompt_master(confirm=True)
    write_db(db, new, data, salt=None)
    print("Master password changed.")

def cmd_export(args):
    db = pathlib.Path(args.db)
    master = prompt_master()
    out = pathlib.Path(args.out)
    try:
        raw = db.read_bytes()
    except Exception as e:
        print("Error reading DB file:", e, file=sys.stderr); sys.exit(2)
    out.write_bytes(raw)
    print(f"Exported encrypted DB to {out}")

def cmd_import(args):
    db = pathlib.Path(args.db)
    inp = pathlib.Path(args.infile)
    if not inp.exists():
        print("Input file not found.", file=sys.stderr); sys.exit(1)
    db.parent.mkdir(parents=True, exist_ok=True)
    db.write_bytes(inp.read_bytes())
    print(f"Imported DB to {db}")

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--db", default=str(DEFAULT_DB), help="Path to encrypted DB file")
    sub = ap.add_subparsers(dest="cmd", required=True)

    sub.add_parser("init")
    p = sub.add_parser("add"); p.add_argument("--name", required=True); p.add_argument("--user"); p.add_argument("--password")
    p = sub.add_parser("get"); p.add_argument("--name", required=True)
    sub.add_parser("list")
    p = sub.add_parser("remove"); p.add_argument("--name", required=True)
    sub.add_parser("change-master")
    p = sub.add_parser("export"); p.add_argument("--out", default="exported_passwords.dat")
    p = sub.add_parser("import"); p.add_argument("--infile", required=True)

    args = ap.parse_args()
    if args.cmd == "init": cmd_init(args)
    elif args.cmd == "add": cmd_add(args)
    elif args.cmd == "get": cmd_get(args)
    elif args.cmd == "list": cmd_list(args)
    elif args.cmd == "remove": cmd_remove(args)
    elif args.cmd == "change-master": cmd_change_master(args)
    elif args.cmd == "export": cmd_export(args)
    elif args.cmd == "import": cmd_import(args)

if __name__ == "__main__":
    main()
